"use strict";(globalThis.webpackChunksaturn_cli_docs=globalThis.webpackChunksaturn_cli_docs||[]).push([[864],{3973:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>g,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"examples","title":"Saturn CLI Examples - Real World Go Job Execution Use Cases","description":"Practical examples of Saturn CLI usage in various scenarios. From basic implementations to advanced patterns for background job execution in Go.","source":"@site/docs/examples.md","sourceDirName":".","slug":"/examples","permalink":"/saturncli/docs/examples","draft":false,"unlisted":false,"editUrl":"https://github.com/Kingson4Wu/saturncli/tree/main/documentation/docs/examples.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8,"title":"Saturn CLI Examples - Real World Go Job Execution Use Cases","description":"Practical examples of Saturn CLI usage in various scenarios. From basic implementations to advanced patterns for background job execution in Go.","keywords":["saturn cli examples","go job execution examples","unix domain sockets examples","background job examples","golang cli examples"]},"sidebar":"tutorialSidebar","previous":{"title":"Embedding Guide - Integrate Saturn CLI into Go Services","permalink":"/saturncli/docs/embedding"},"next":{"title":"Troubleshooting Saturn CLI - Common Issues & Solutions","permalink":"/saturncli/docs/troubleshooting"}}');var s=r(4848),i=r(8453);const o={sidebar_position:8,title:"Saturn CLI Examples - Real World Go Job Execution Use Cases",description:"Practical examples of Saturn CLI usage in various scenarios. From basic implementations to advanced patterns for background job execution in Go.",keywords:["saturn cli examples","go job execution examples","unix domain sockets examples","background job examples","golang cli examples"]},a="Examples",l={},c=[{value:"Basic Examples",id:"basic-examples",level:2},{value:"Simple Job Execution",id:"simple-job-execution",level:3},{value:"Stoppable Job Example",id:"stoppable-job-example",level:3},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"File Processing Service",id:"file-processing-service",level:3},{value:"Data Backup Service",id:"data-backup-service",level:3},{value:"Monitoring Service",id:"monitoring-service",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Multi-Registry Service",id:"multi-registry-service",level:3},{value:"Client Usage Examples",id:"client-usage-examples",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"REST API Integration",id:"rest-api-integration",level:3},{value:"Testing Examples",id:"testing-examples",level:2},{value:"Unit Testing Saturn Jobs",id:"unit-testing-saturn-jobs",level:3},{value:"Best Practices Demonstrated",id:"best-practices-demonstrated",level:2},{value:"Running the Examples",id:"running-the-examples",level:2},{value:"See Also",id:"see-also",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"examples",children:"Examples"})}),"\n",(0,s.jsx)(n.p,{children:"This page provides practical examples of Saturn CLI usage in various scenarios, from basic implementations to advanced patterns for executing background jobs in Go applications."}),"\n",(0,s.jsx)(n.h2,{id:"basic-examples",children:"Basic Examples"}),"\n",(0,s.jsx)(n.h3,{id:"simple-job-execution",children:"Simple Job Execution"}),"\n",(0,s.jsx)(n.p,{children:"The most basic example of using Saturn CLI is to register a simple job and execute it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "log"\n    \n    "github.com/Kingson4Wu/saturncli/server"\n    "github.com/Kingson4Wu/saturncli/utils"\n)\n\nfunc main() {\n    // Register a simple job\n    if err := server.AddJob("hello", func(args map[string]string, signature string) bool {\n        name := args["name"]\n        if name == "" {\n            name = "World"\n        }\n        fmt.Printf("Hello, %s! (Run: %s)\\n", name, signature)\n        return true\n    }); err != nil {\n        log.Fatal(err)\n    }\n    \n    // Start the server\n    server.NewServer(&utils.DefaultLogger{}, "/tmp/hello.sock").Serve()\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"To run this example:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Build: ",(0,s.jsx)(n.code,{children:"go build -o hello_server main.go"})]}),"\n",(0,s.jsxs)(n.li,{children:["Start server: ",(0,s.jsx)(n.code,{children:"./hello_server"})]}),"\n",(0,s.jsxs)(n.li,{children:["In another terminal: ",(0,s.jsx)(n.code,{children:"./saturn_cli --name hello --param name=Alice"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"stoppable-job-example",children:"Stoppable Job Example"}),"\n",(0,s.jsx)(n.p,{children:"A job that can be cancelled gracefully:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "log"\n    "time"\n    \n    "github.com/Kingson4Wu/saturncli/server"\n    "github.com/Kingson4Wu/saturncli/utils"\n)\n\nfunc main() {\n    if err := server.AddStoppableJob("countdown", func(args map[string]string, signature string, quit chan struct{}) bool {\n        duration := 10 // default to 10 seconds\n        if args["duration"] != "" {\n            // In a real app, parse this safely\n            fmt.Sscanf(args["duration"], "%d", &duration)\n        }\n        \n        fmt.Printf("Starting countdown for %d seconds (Run: %s)\\n", duration, signature)\n        \n        for i := duration; i >= 0; i-- {\n            select {\n            case <-quit:\n                fmt.Printf("Countdown stopped early at %d seconds (Run: %s)\\n", i, signature)\n                return true\n            case <-time.After(1 * time.Second):\n                fmt.Printf("%d... ", i)\n                if i == 0 {\n                    fmt.Println("Liftoff!")\n                }\n            }\n        }\n        return true\n    }); err != nil {\n        log.Fatal(err)\n    }\n    \n    server.NewServer(&utils.DefaultLogger{}, "/tmp/countdown.sock").Serve()\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,s.jsx)(n.h3,{id:"file-processing-service",children:"File Processing Service"}),"\n",(0,s.jsx)(n.p,{children:"A service that processes files with progress tracking:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "log"\n    "os"\n    "path/filepath"\n    "strings"\n    "time"\n    \n    "github.com/Kingson4Wu/saturncli/server"\n    "github.com/Kingson4Wu/saturncli/utils"\n)\n\ntype FileProcessor struct {\n    logger utils.Logger\n}\n\nfunc NewFileProcessor(logger utils.Logger) *FileProcessor {\n    return &FileProcessor{logger: logger}\n}\n\nfunc (fp *FileProcessor) ProcessFilesJob(args map[string]string, signature string, quit chan struct{}) bool {\n    inputDir := args["input_dir"]\n    outputDir := args["output_dir"]\n    \n    if inputDir == "" || outputDir == "" {\n        fp.logger.Errorf("Missing required parameters for job %s", signature)\n        return false\n    }\n    \n    // Validate directories exist\n    if _, err := os.Stat(inputDir); os.IsNotExist(err) {\n        fp.logger.Errorf("Input directory does not exist: %s", inputDir)\n        return false\n    }\n    \n    if _, err := os.Stat(outputDir); os.IsNotExist(err) {\n        fp.logger.Errorf("Output directory does not exist: %s", outputDir)\n        return false\n    }\n    \n    fp.logger.Infof("Starting file processing job %s from %s to %s", signature, inputDir, outputDir)\n    \n    // Get all .txt files in the input directory\n    files, err := filepath.Glob(filepath.Join(inputDir, "*.txt"))\n    if err != nil {\n        fp.logger.Errorf("Error finding files: %v", err)\n        return false\n    }\n    \n    if len(files) == 0 {\n        fp.logger.Infof("No .txt files found in %s", inputDir)\n        return true\n    }\n    \n    processedCount := 0\n    for _, file := range files {\n        select {\n        case <-quit:\n            fp.logger.Infof("File processing job %s cancelled after processing %d files", signature, processedCount)\n            return true\n        default:\n            if fp.processFile(file, outputDir, signature) {\n                processedCount++\n            }\n        }\n    }\n    \n    fp.logger.Infof("File processing job %s completed. Processed %d files", signature, processedCount)\n    return true\n}\n\nfunc (fp *FileProcessor) processFile(inputPath, outputDir, signature string) bool {\n    // Simulate file processing\n    fp.logger.Debugf("Processing file: %s for job %s", inputPath, signature)\n    \n    // In a real implementation, you would:\n    // 1. Read the file\n    // 2. Process its contents\n    // 3. Write to the output directory\n    // 4. Handle errors appropriately\n    \n    // Simulate processing time\n    time.Sleep(500 * time.Millisecond)\n    \n    // Generate output filename\n    filename := filepath.Base(inputPath)\n    nameWithoutExt := strings.TrimSuffix(filename, filepath.Ext(filename))\n    outputPath := filepath.Join(outputDir, fmt.Sprintf("%s_processed.txt", nameWithoutExt))\n    \n    fp.logger.Debugf("Would write processed output to: %s", outputPath)\n    \n    return true\n}\n\nfunc main() {\n    logger := &utils.DefaultLogger{}\n    processor := NewFileProcessor(logger)\n    \n    registry := server.NewRegistry()\n    \n    if err := registry.AddStoppableJob("process_files", processor.ProcessFilesJob); err != nil {\n        log.Fatal(err)\n    }\n    \n    server.NewServer(logger, "/tmp/file_processor.sock", server.WithRegistry(registry)).Serve()\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"data-backup-service",children:"Data Backup Service"}),"\n",(0,s.jsx)(n.p,{children:"A backup service that can be stopped gracefully:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "context"\n    "fmt"\n    "log"\n    "os"\n    "path/filepath"\n    "time"\n    \n    "github.com/Kingson4Wu/saturncli/server"\n    "github.com/Kingson4Wu/saturncli/utils"\n)\n\ntype BackupService struct {\n    logger utils.Logger\n}\n\nfunc NewBackupService(logger utils.Logger) *BackupService {\n    return &BackupService{logger: logger}\n}\n\nfunc (bs *BackupService) BackupJob(args map[string]string, signature string, quit chan struct{}) bool {\n    source := args["source"]\n    destination := args["destination"]\n    compress := args["compress"] == "true"\n    \n    if source == "" || destination == "" {\n        bs.logger.Errorf("Missing source or destination for backup job %s", signature)\n        return false\n    }\n    \n    // Check if source exists\n    if _, err := os.Stat(source); os.IsNotExist(err) {\n        bs.logger.Errorf("Source does not exist: %s", source)\n        return false\n    }\n    \n    bs.logger.Infof("Starting backup job %s: %s -> %s (compress: %t)", \n                     signature, source, destination, compress)\n    \n    // Create backup directory if it doesn\'t exist\n    if err := os.MkdirAll(destination, 0755); err != nil {\n        bs.logger.Errorf("Failed to create destination directory: %v", err)\n        return false\n    }\n    \n    // Simulate backup process\n    ticker := time.NewTicker(2 * time.Second)\n    defer ticker.Stop()\n    \n    backupSteps := []string{"scanning", "copying", "verifying", "finalizing"}\n    for _, step := range backupSteps {\n        select {\n        case <-quit:\n            bs.logger.Infof("Backup job %s cancelled during %s step", signature, step)\n            return true\n        case <-ticker.C:\n            bs.logger.Infof("Backup job %s: %s...", step)\n            // Simulate work for each step\n            time.Sleep(1 * time.Second)\n        }\n    }\n    \n    // In a real implementation, you would actually copy the files\n    timestamp := time.Now().Format("2006-01-02-15-04-05")\n    backupName := fmt.Sprintf("backup_%s_%s", filepath.Base(source), timestamp)\n    backupPath := filepath.Join(destination, backupName)\n    \n    bs.logger.Infof("Created backup: %s", backupPath)\n    bs.logger.Infof("Backup job %s completed successfully", signature)\n    \n    return true\n}\n\nfunc main() {\n    logger := &utils.DefaultLogger{}\n    backupService := NewBackupService(logger)\n    \n    registry := server.NewRegistry()\n    \n    if err := registry.AddStoppableJob("backup_data", backupService.BackupJob); err != nil {\n        log.Fatal(err)\n    }\n    \n    server.NewServer(logger, "/tmp/backup_service.sock", server.WithRegistry(registry)).Serve()\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"monitoring-service",children:"Monitoring Service"}),"\n",(0,s.jsx)(n.p,{children:"A service that continuously monitors system resources:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "log"\n    "math/rand"\n    "time"\n    \n    "github.com/Kingson4Wu/saturncli/server"\n    "github.com/Kingson4Wu/saturncli/utils"\n)\n\ntype MonitorService struct {\n    logger utils.Logger\n}\n\nfunc NewMonitorService(logger utils.Logger) *MonitorService {\n    return &MonitorService{logger: logger}\n}\n\nfunc (ms *MonitorService) SystemMonitorJob(args map[string]string, signature string, quit chan struct{}) bool {\n    interval := 5 // default to 5 seconds\n    if args["interval"] != "" {\n        fmt.Sscanf(args["interval"], "%d", &interval)\n    }\n    \n    ms.logger.Infof("Starting system monitor job %s with %d second intervals", signature, interval)\n    \n    ticker := time.NewTicker(time.Duration(interval) * time.Second)\n    defer ticker.Stop()\n    \n    iteration := 0\n    for {\n        select {\n        case <-quit:\n            ms.logger.Infof("System monitor job %s stopped after %d iterations", signature, iteration)\n            return true\n        case <-ticker.C:\n            iteration++\n            // Simulate monitoring metrics\n            cpu := rand.Float64() * 100 // Random CPU usage 0-100%\n            memory := rand.Float64() * 100 // Random memory usage 0-100%\n            disk := rand.Float64() * 100 // Random disk usage 0-100%\n            \n            ms.logger.Infof("Monitor %s - Iteration %d: CPU=%.2f%%, Memory=%.2f%%, Disk=%.2f%%", \n                            signature, iteration, cpu, memory, disk)\n            \n            // In a real implementation, you would:\n            // 1. Collect actual system metrics\n            // 2. Send them to a monitoring system\n            // 3. Trigger alerts if thresholds are exceeded\n        }\n    }\n}\n\nfunc (ms *MonitorService) HealthCheckJob(args map[string]string, signature string) bool {\n    service := args["service"]\n    if service == "" {\n        service = "unknown"\n    }\n    \n    // Simulate health check logic\n    ms.logger.Infof("Performing health check for service: %s (Run: %s)", service, signature)\n    \n    // Simulate checking service status\n    // In real implementation, you would check actual service status\n    time.Sleep(500 * time.Millisecond)\n    \n    // Simulate 95% success rate\n    success := rand.Float64() < 0.95\n    \n    if success {\n        ms.logger.Infof("Health check for service %s passed", service)\n        return true\n    } else {\n        ms.logger.Errorf("Health check for service %s failed", service)\n        return false\n    }\n}\n\nfunc main() {\n    logger := &utils.DefaultLogger{}\n    monitorService := NewMonitorService(logger)\n    \n    registry := server.NewRegistry()\n    \n    if err := registry.AddStoppableJob("system_monitor", monitorService.SystemMonitorJob); err != nil {\n        log.Fatal(err)\n    }\n    \n    if err := registry.AddJob("health_check", monitorService.HealthCheckJob); err != nil {\n        log.Fatal(err)\n    }\n    \n    server.NewServer(logger, "/tmp/monitor_service.sock", server.WithRegistry(registry)).Serve()\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"multi-registry-service",children:"Multi-Registry Service"}),"\n",(0,s.jsx)(n.p,{children:"A service that uses multiple registries for different purposes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "log"\n    \n    "github.com/Kingson4Wu/saturncli/server"\n    "github.com/Kingson4Wu/saturncli/utils"\n)\n\nfunc main() {\n    logger := &utils.DefaultLogger{}\n    \n    // Create separate registries for different concerns\n    criticalJobs := server.NewRegistry()\n    backgroundJobs := server.NewRegistry()\n    \n    // Register critical jobs\n    if err := criticalJobs.AddJob("validate_data", func(args map[string]string, signature string) bool {\n        log.Printf("Running critical validation job: %s", signature)\n        // Implement critical validation logic\n        return true\n    }); err != nil {\n        log.Fatal(err)\n    }\n    \n    // Register background jobs\n    if err := backgroundJobs.AddStoppableJob("cleanup", func(args map[string]string, signature string, quit chan struct{}) bool {\n        log.Printf("Running background cleanup: %s", signature)\n        // Implement cleanup logic that can be stopped\n        return true\n    }); err != nil {\n        log.Fatal(err)\n    }\n    \n    // You could run multiple servers or combine them\n    // For this example, we\'ll use a single server with the critical jobs registry\n    server.NewServer(logger, "/tmp/multi_service.sock", server.WithRegistry(criticalJobs)).Serve()\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"client-usage-examples",children:"Client Usage Examples"}),"\n",(0,s.jsx)(n.p,{children:"Examples of how to use the client programmatically:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "time"\n    \n    "github.com/Kingson4Wu/saturncli/client"\n    "github.com/Kingson4Wu/saturncli/base"\n    "github.com/Kingson4Wu/saturncli/utils"\n)\n\nfunc main() {\n    cli := client.NewClient(&utils.DefaultLogger{}, "/tmp/example.sock")\n    \n    // Example 1: Simple job execution\n    fmt.Println("Executing simple job...")\n    result := cli.Run(&client.Task{\n        Name:   "hello",\n        Params: map[string]string{"name": "Saturn User"},\n    })\n    \n    switch result {\n    case base.SUCCESS:\n        fmt.Println("Job completed successfully")\n    case base.FAILURE:\n        fmt.Println("Job failed")\n    case base.INTERRUPT:\n        fmt.Println("Job was interrupted")\n    }\n    \n    // Example 2: Job with multiple parameters\n    fmt.Println("\\nExecuting job with multiple parameters...")\n    result = cli.Run(&client.Task{\n        Name: "process_data",\n        Params: map[string]string{\n            "input_file":  "/path/to/input",\n            "output_file": "/path/to/output",\n            "format":      "json",\n            "validate":    "true",\n        },\n    })\n    \n    if result == base.SUCCESS {\n        fmt.Println("Data processing completed")\n    } else {\n        fmt.Println("Data processing failed")\n    }\n    \n    // Example 3: Stopping a job\n    fmt.Println("\\nStopping a running job...")\n    result = cli.Run(&client.Task{\n        Name:      "long_running_task",\n        Stop:      true,\n        Signature: "task-to-stop", // Specify which instance to stop\n    })\n    \n    fmt.Printf("Stop result: %v\\n", result)\n    \n    // Example 4: Error handling\n    fmt.Println("\\nExecuting non-existent job...")\n    result = cli.Run(&client.Task{\n        Name: "non_existent_job",\n    })\n    \n    if result == base.FAILURE {\n        fmt.Println("As expected, job failed because it doesn\'t exist")\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,s.jsx)(n.h3,{id:"rest-api-integration",children:"REST API Integration"}),"\n",(0,s.jsx)(n.p,{children:"Integrating Saturn CLI with a REST API:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "encoding/json"\n    "log"\n    "net/http"\n    \n    "github.com/Kingson4Wu/saturncli/client"\n    "github.com/Kingson4Wu/saturncli/base"\n    "github.com/Kingson4Wu/saturncli/utils"\n)\n\ntype APIServer struct {\n    saturnClient *client.cli\n}\n\ntype JobRequest struct {\n    Name   string            `json:"name"`\n    Params map[string]string `json:"params"`\n}\n\ntype JobResponse struct {\n    Success bool   `json:"success"`\n    Message string `json:"message"`\n}\n\nfunc NewAPIServer() *APIServer {\n    return &APIServer{\n        saturnClient: client.NewClient(&utils.DefaultLogger{}, "/tmp/api_integration.sock"),\n    }\n}\n\nfunc (api *APIServer) JobHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method != http.MethodPost {\n        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)\n        return\n    }\n    \n    var req JobRequest\n    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n        http.Error(w, "Invalid JSON", http.StatusBadRequest)\n        return\n    }\n    \n    result := api.saturnClient.Run(&client.Task{\n        Name:   req.Name,\n        Params: req.Params,\n    })\n    \n    resp := JobResponse{\n        Success: result == base.SUCCESS,\n        Message: "Job executed",\n    }\n    \n    w.Header().Set("Content-Type", "application/json")\n    json.NewEncoder(w).Encode(resp)\n}\n\nfunc main() {\n    apiServer := NewAPIServer()\n    \n    http.HandleFunc("/jobs", apiServer.JobHandler)\n    \n    log.Println("Starting API server on :8080")\n    log.Fatal(http.ListenAndServe(":8080", nil))\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-examples",children:"Testing Examples"}),"\n",(0,s.jsx)(n.h3,{id:"unit-testing-saturn-jobs",children:"Unit Testing Saturn Jobs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "bytes"\n    "fmt"\n    "io"\n    "strings"\n    "testing"\n)\n\ntype TestLogger struct {\n    buffer *bytes.Buffer\n}\n\nfunc (tl *TestLogger) Info(msg string) {\n    tl.buffer.WriteString("INFO: " + msg + "\\n")\n}\n\nfunc (tl *TestLogger) Infof(format string, args ...interface{}) {\n    tl.buffer.WriteString("INFO: " + fmt.Sprintf(format, args...) + "\\n")\n}\n\nfunc (tl *TestLogger) Error(msg string) {\n    tl.buffer.WriteString("ERROR: " + msg + "\\n")\n}\n\nfunc (tl *TestLogger) Errorf(format string, args ...interface{}) {\n    tl.buffer.WriteString("ERROR: " + fmt.Sprintf(format, args...) + "\\n")\n}\n\nfunc (tl *TestLogger) Debug(msg string) {\n    tl.buffer.WriteString("DEBUG: " + msg + "\\n")\n}\n\nfunc (tl *TestLogger) Debugf(format string, args ...interface{}) {\n    tl.buffer.WriteString("DEBUG: " + fmt.Sprintf(format, args...) + "\\n")\n}\n\nfunc (tl *TestLogger) Warn(msg string) {\n    tl.buffer.WriteString("WARN: " + msg + "\\n")\n}\n\nfunc (tl *TestLogger) Warnf(format string, args ...interface{}) {\n    tl.buffer.WriteString("WARN: " + fmt.Sprintf(format, args...) + "\\n")\n}\n\n// Example test\nfunc TestHelloJob(t *testing.T) {\n    var logBuffer bytes.Buffer\n    testLogger := &TestLogger{buffer: &logBuffer}\n    \n    // Create the job handler\n    handler := func(args map[string]string, signature string) bool {\n        name := args["name"]\n        if name == "" {\n            name = "World"\n        }\n        testLogger.Infof("Hello, %s! (Run: %s)", name, signature)\n        return true\n    }\n    \n    // Test with parameters\n    args := map[string]string{"name": "TestUser"}\n    signature := "test-signature"\n    result := handler(args, signature)\n    \n    if !result {\n        t.Error("Expected job to return true")\n    }\n    \n    logOutput := logBuffer.String()\n    if !strings.Contains(logOutput, "Hello, TestUser!") {\n        t.Errorf("Expected log to contain \'Hello, TestUser!\', got: %s", logOutput)\n    }\n    \n    if !strings.Contains(logOutput, "test-signature") {\n        t.Errorf("Expected log to contain signature, got: %s", logOutput)\n    }\n}\n\nfunc TestStoppableJob(t *testing.T) {\n    quit := make(chan struct{})\n    done := make(chan bool, 1)\n    \n    handler := func(args map[string]string, signature string, quit chan struct{}) bool {\n        counter := 0\n        for {\n            select {\n            case <-quit:\n                return true\n            default:\n                counter++\n                if counter > 5 { // Limit iterations to avoid hanging tests\n                    return true\n                }\n            }\n        }\n    }\n    \n    args := map[string]string{}\n    signature := "test-stop"\n    \n    // Run the handler in a goroutine\n    go func() {\n        result := handler(args, signature, quit)\n        done <- result\n    }()\n    \n    // Allow some iterations\n    time.Sleep(100 * time.Millisecond)\n    \n    // Close the quit channel to stop the job\n    close(quit)\n    \n    // Wait for the handler to finish\n    select {\n    case result := <-done:\n        if !result {\n            t.Error("Expected stoppable job to return true after being stopped")\n        }\n    case <-time.After(1 * time.Second):\n        t.Error("Test timed out")\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-demonstrated",children:"Best Practices Demonstrated"}),"\n",(0,s.jsx)(n.p,{children:"These examples demonstrate several best practices:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"}),": Always validate inputs and handle errors gracefully"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Management"}),": Properly manage file handles, connections, and other resources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cancellation Support"}),": Use quit channels in stoppable jobs for graceful shutdown"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Logging"}),": Use structured logging for debugging and monitoring"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameter Validation"}),": Validate parameters to prevent injection attacks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Testing"}),": Write comprehensive tests for your Saturn jobs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Documentation"}),": Document your custom job interfaces and expected parameters"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"running-the-examples",children:"Running the Examples"}),"\n",(0,s.jsx)(n.p,{children:"To run any of these examples:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create a new directory for the example"}),"\n",(0,s.jsxs)(n.li,{children:["Create a ",(0,s.jsx)(n.code,{children:"main.go"})," file with the example code"]}),"\n",(0,s.jsxs)(n.li,{children:["Run ",(0,s.jsx)(n.code,{children:"go mod init example_name"})]}),"\n",(0,s.jsxs)(n.li,{children:["Run ",(0,s.jsx)(n.code,{children:"go get github.com/Kingson4Wu/saturncli"})]}),"\n",(0,s.jsxs)(n.li,{children:["Build with ",(0,s.jsx)(n.code,{children:"go build -o example_name main.go"})]}),"\n",(0,s.jsxs)(n.li,{children:["Create the necessary socket directory: ",(0,s.jsx)(n.code,{children:"mkdir -p /tmp"})]}),"\n",(0,s.jsxs)(n.li,{children:["Run the server: ",(0,s.jsx)(n.code,{children:"./example_name"})]}),"\n",(0,s.jsx)(n.li,{children:"In another terminal, use the Saturn CLI to trigger jobs"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/saturncli/docs/getting-started",children:"Getting Started Guide"})," - Basic setup and usage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/saturncli/docs/embedding",children:"Embedding Guide"})," - How to integrate Saturn into your services"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/saturncli/docs/client-api",children:"Client API Reference"})," and ",(0,s.jsx)(n.a,{href:"/saturncli/docs/server-api",children:"Server API Reference"})," - Technical API documentation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/saturncli/docs/architecture",children:"Architecture"})," - Understanding the system design"]}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(6540);const s={},i=t.createContext(s);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);