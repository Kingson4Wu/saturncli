"use strict";(globalThis.webpackChunksaturn_cli_docs=globalThis.webpackChunksaturn_cli_docs||[]).push([[133],{3504:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"testing","title":"Testing Strategies - Saturn CLI Job and Server Testing","description":"Comprehensive testing strategies for Saturn CLI. Learn how to test your own jobs and verify Saturn CLI functionality for reliable job execution.","source":"@site/docs/testing.md","sourceDirName":".","slug":"/testing","permalink":"/saturncli/docs/testing","draft":false,"unlisted":false,"editUrl":"https://github.com/Kingson4Wu/saturncli/tree/main/documentation/docs/testing.md","tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"sidebar_position":12,"title":"Testing Strategies - Saturn CLI Job and Server Testing","description":"Comprehensive testing strategies for Saturn CLI. Learn how to test your own jobs and verify Saturn CLI functionality for reliable job execution.","keywords":["saturn cli testing","go cli testing","job execution testing","saturn cli tests","go background job testing","cli testing strategies"]},"sidebar":"tutorialSidebar","previous":{"title":"Development Setup - Saturn CLI Environment Configuration","permalink":"/saturncli/docs/development-setup"}}');var s=t(4848),i=t(8453);const o={sidebar_position:12,title:"Testing Strategies - Saturn CLI Job and Server Testing",description:"Comprehensive testing strategies for Saturn CLI. Learn how to test your own jobs and verify Saturn CLI functionality for reliable job execution.",keywords:["saturn cli testing","go cli testing","job execution testing","saturn cli tests","go background job testing","cli testing strategies"]},a="Testing",c={},l=[{value:"Testing Overview",id:"testing-overview",level:2},{value:"Testing Philosophy",id:"testing-philosophy",level:3},{value:"Unit Testing Job Handlers",id:"unit-testing-job-handlers",level:2},{value:"Testing Regular Jobs",id:"testing-regular-jobs",level:3},{value:"Testing Stoppable Jobs",id:"testing-stoppable-jobs",level:3},{value:"Testing with Mock Dependencies",id:"testing-with-mock-dependencies",level:2},{value:"Mocking External Dependencies",id:"mocking-external-dependencies",level:3},{value:"Integration Testing",id:"integration-testing",level:2},{value:"Testing Client-Server Integration",id:"testing-client-server-integration",level:3},{value:"Testing with Test Servers",id:"testing-with-test-servers",level:2},{value:"Creating Test-Specific Servers",id:"creating-test-specific-servers",level:3},{value:"Testing Error Conditions",id:"testing-error-conditions",level:2},{value:"Testing Error Handling",id:"testing-error-handling",level:3},{value:"Performance Testing",id:"performance-testing",level:2},{value:"Benchmarking Jobs",id:"benchmarking-jobs",level:3},{value:"Memory Profiling",id:"memory-profiling",level:3},{value:"Testing Utilities and Helpers",id:"testing-utilities-and-helpers",level:2},{value:"Test Helpers",id:"test-helpers",level:3},{value:"Continuous Testing",id:"continuous-testing",level:2},{value:"Test Organization and Running",id:"test-organization-and-running",level:3},{value:"Test Environment Setup",id:"test-environment-setup",level:3},{value:"Testing Best Practices",id:"testing-best-practices",level:2},{value:"What to Test",id:"what-to-test",level:3},{value:"What NOT to Test",id:"what-not-to-test",level:3},{value:"Test Naming Conventions",id:"test-naming-conventions",level:3},{value:"Troubleshooting Tests",id:"troubleshooting-tests",level:2},{value:"Common Testing Issues",id:"common-testing-issues",level:3},{value:"Flaky Tests",id:"flaky-tests",level:4},{value:"Resource Conflicts",id:"resource-conflicts",level:4},{value:"Next Steps",id:"next-steps",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"testing",children:"Testing"})}),"\n",(0,s.jsx)(n.p,{children:"This guide covers comprehensive testing strategies for Saturn CLI - both testing your own jobs and testing Saturn CLI itself for reliable job execution."}),"\n",(0,s.jsx)(n.h2,{id:"testing-overview",children:"Testing Overview"}),"\n",(0,s.jsx)(n.p,{children:"Saturn CLI follows Go's standard testing practices with additional patterns for testing concurrent and network-dependent components."}),"\n",(0,s.jsx)(n.h3,{id:"testing-philosophy",children:"Testing Philosophy"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fast Feedback"}),": Tests should run quickly to provide immediate feedback"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reliability"}),": Tests should be deterministic and not flaky"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maintainability"}),": Tests should be easy to understand and modify"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Coverage"}),": Aim for high test coverage, especially around critical paths"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Integration"}),": Test both individual components and their integration"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"unit-testing-job-handlers",children:"Unit Testing Job Handlers"}),"\n",(0,s.jsx)(n.h3,{id:"testing-regular-jobs",children:"Testing Regular Jobs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "bytes"\n    "fmt"\n    "strings"\n    "testing"\n)\n\n// Example job handler to test\nfunc exampleJob(args map[string]string, signature string) bool {\n    if args["fail"] == "true" {\n        return false\n    }\n    \n    expected := args["expected"]\n    actual := args["actual"]\n    \n    return expected == actual\n}\n\nfunc TestExampleJob(t *testing.T) {\n    tests := []struct {\n        name     string\n        args     map[string]string\n        expected bool\n    }{\n        {\n            name: "matching values return true",\n            args: map[string]string{\n                "expected": "value",\n                "actual":   "value",\n            },\n            expected: true,\n        },\n        {\n            name: "different values return false",\n            args: map[string]string{\n                "expected": "value1",\n                "actual":   "value2",\n            },\n            expected: false,\n        },\n        {\n            name: "fail flag returns false",\n            args: map[string]string{\n                "fail": "true",\n            },\n            expected: false,\n        },\n        {\n            name:     "empty args return false",\n            args:     map[string]string{},\n            expected: true, // because expected and actual are both empty strings\n        },\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            result := exampleJob(tt.args, "test-signature")\n            if result != tt.expected {\n                t.Errorf("expected %v, got %v", tt.expected, result)\n            }\n        })\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"testing-stoppable-jobs",children:"Testing Stoppable Jobs"}),"\n",(0,s.jsx)(n.p,{children:"Testing stoppable jobs requires special handling for the quit channel:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "sync"\n    "testing"\n    "time"\n)\n\nfunc exampleStoppableJob(args map[string]string, signature string, quit chan struct{}) bool {\n    maxIterations := 10\n    if args["max"] != "" {\n        fmt.Sscanf(args["max"], "%d", &maxIterations)\n    }\n    \n    for i := 0; i < maxIterations; i++ {\n        select {\n        case <-quit:\n            return true // Successfully stopped\n        case <-time.After(10 * time.Millisecond):\n            // Continue working\n        }\n    }\n    \n    return true // Completed normally\n}\n\nfunc TestStoppableJobStop(t *testing.T) {\n    quit := make(chan struct{})\n    done := make(chan bool, 1)\n    \n    args := map[string]string{"max": "100"} // High number to ensure it would run long\n    \n    // Run the job in a goroutine\n    go func() {\n        result := exampleStoppableJob(args, "test-sig", quit)\n        done <- result\n    }()\n    \n    // Allow some time for the job to start\n    time.Sleep(50 * time.Millisecond)\n    \n    // Signal to quit\n    close(quit)\n    \n    // Wait for job to complete with timeout\n    select {\n    case result := <-done:\n        if !result {\n            t.Error("Expected job to return true when stopped")\n        }\n    case <-time.After(2 * time.Second):\n        t.Error("Job did not respond to quit signal in time")\n    }\n}\n\nfunc TestStoppableJobComplete(t *testing.T) {\n    quit := make(chan struct{})\n    done := make(chan bool, 1)\n    \n    args := map[string]string{"max": "3"} // Small number to complete quickly\n    \n    go func() {\n        result := exampleStoppableJob(args, "test-sig", quit)\n        done <- result\n    }()\n    \n    // Wait for job to complete with timeout\n    select {\n    case result := <-done:\n        if !result {\n            t.Error("Expected job to return true when completed normally")\n        }\n    case <-time.After(2 * time.Second):\n        t.Error("Job did not complete in time")\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-with-mock-dependencies",children:"Testing with Mock Dependencies"}),"\n",(0,s.jsx)(n.h3,{id:"mocking-external-dependencies",children:"Mocking External Dependencies"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "testing"\n)\n\n// Interface to make code testable\ntype ResourceService interface {\n    GetData(id string) (string, error)\n    SaveData(id, data string) error\n}\n\n// Real implementation\ntype RealResourceService struct{}\n\nfunc (r *RealResourceService) GetData(id string) (string, error) {\n    // Real implementation that might access database, API, etc.\n    return fmt.Sprintf("data-for-%s", id), nil\n}\n\nfunc (r *RealResourceService) SaveData(id, data string) error {\n    // Real implementation\n    return nil\n}\n\n// Job that uses external service\nfunc jobWithDependency(service ResourceService, args map[string]string, signature string) bool {\n    id := args["id"]\n    if id == "" {\n        return false\n    }\n    \n    data, err := service.GetData(id)\n    if err != nil {\n        return false\n    }\n    \n    return service.SaveData(id, data) == nil\n}\n\n// Mock implementation for testing\ntype MockResourceService struct {\n    GetDataFunc func(id string) (string, error)\n    SaveDataFunc func(id, data string) error\n}\n\nfunc (m *MockResourceService) GetData(id string) (string, error) {\n    if m.GetDataFunc != nil {\n        return m.GetDataFunc(id)\n    }\n    return "", nil\n}\n\nfunc (m *MockResourceService) SaveData(id, data string) error {\n    if m.SaveDataFunc != nil {\n        return m.SaveDataFunc(id, data)\n    }\n    return nil\n}\n\nfunc TestJobWithDependencySuccess(t *testing.T) {\n    mockService := &MockResourceService{\n        GetDataFunc: func(id string) (string, error) {\n            if id == "valid-id" {\n                return "test-data", nil\n            }\n            return "", fmt.Errorf("not found")\n        },\n        SaveDataFunc: func(id, data string) error {\n            if id == "valid-id" && data == "test-data" {\n                return nil\n            }\n            return fmt.Errorf("save failed")\n        },\n    }\n    \n    args := map[string]string{"id": "valid-id"}\n    result := jobWithDependency(mockService, args, "test-sig")\n    \n    if !result {\n        t.Error("Expected job to succeed with valid dependencies")\n    }\n}\n\nfunc TestJobWithDependencyFailure(t *testing.T) {\n    mockService := &MockResourceService{\n        GetDataFunc: func(id string) (string, error) {\n            return "", fmt.Errorf("service unavailable")\n        },\n    }\n    \n    args := map[string]string{"id": "any-id"}\n    result := jobWithDependency(mockService, args, "test-sig")\n    \n    if result {\n        t.Error("Expected job to fail when dependency fails")\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,s.jsx)(n.h3,{id:"testing-client-server-integration",children:"Testing Client-Server Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "sync"\n    "testing"\n    "time"\n\n    "github.com/Kingson4Wu/saturncli/client"\n    "github.com/Kingson4Wu/saturncli/server"\n    "github.com/Kingson4Wu/saturncli/base"\n    "github.com/Kingson4Wu/saturncli/utils"\n)\n\nfunc TestClientServerIntegration(t *testing.T) {\n    socketPath := "/tmp/test_integration.sock"\n    \n    // Register a test job\n    testJobExecuted := false\n    testJobMutex := sync.Mutex{}\n    \n    jobHandler := func(args map[string]string, signature string) bool {\n        testJobMutex.Lock()\n        testJobExecuted = true\n        testJobMutex.Unlock()\n        return true\n    }\n    \n    if err := server.AddJob("integration-test", jobHandler); err != nil {\n        t.Fatalf("Failed to register test job: %v", err)\n    }\n    \n    // Start server in goroutine\n    serverStarted := make(chan bool)\n    go func() {\n        serverStarted <- true\n        server.NewServer(&utils.DefaultLogger{}, socketPath).Serve()\n    }()\n    \n    // Give server time to start\n    <-serverStarted\n    time.Sleep(100 * time.Millisecond)\n    \n    // Create client and run job\n    cli := client.NewClient(&utils.DefaultLogger{}, socketPath)\n    result := cli.Run(&client.Task{\n        Name: "integration-test",\n        Params: map[string]string{\n            "test": "value",\n        },\n    })\n    \n    if result != base.SUCCESS {\n        t.Errorf("Expected SUCCESS, got %v", result)\n    }\n    \n    // Verify job was executed\n    testJobMutex.Lock()\n    executed := testJobExecuted\n    testJobMutex.Unlock()\n    \n    if !executed {\n        t.Error("Expected test job to be executed")\n    }\n}\n\nfunc TestStoppableJobIntegration(t *testing.T) {\n    socketPath := "/tmp/test_stoppable_integration.sock"\n    \n    // Track if job was cancelled\n    jobWasCancelled := false\n    \n    stoppableJob := func(args map[string]string, signature string, quit chan struct{}) bool {\n        for i := 0; i < 100; i++ { // Long-running job\n            select {\n            case <-quit:\n                jobWasCancelled = true\n                return true\n            case <-time.After(10 * time.Millisecond):\n                // Do work\n            }\n        }\n        return true\n    }\n    \n    if err := server.AddStoppableJob("stop-test", stoppableJob); err != nil {\n        t.Fatalf("Failed to register stoppable test job: %v", err)\n    }\n    \n    // Start server\n    go server.NewServer(&utils.DefaultLogger{}, socketPath).Serve()\n    \n    // Give server time to start\n    time.Sleep(100 * time.Millisecond)\n    \n    // Start the job\n    cli := client.NewClient(&utils.DefaultLogger{}, socketPath)\n    go func() {\n        result := cli.Run(&client.Task{\n            Name: "stop-test",\n        })\n        if result != base.INTERRUPT { // Expected since we\'ll stop it\n            t.Errorf("Expected INTERRUPT, got %v", result)\n        }\n    }()\n    \n    // Let it run a bit\n    time.Sleep(50 * time.Millisecond)\n    \n    // Stop the job\n    stopResult := cli.Run(&client.Task{\n        Name: "stop-test",\n        Stop: true,\n    })\n    \n    if stopResult != base.SUCCESS {\n        t.Errorf("Expected SUCCESS from stop, got %v", stopResult)\n    }\n    \n    if !jobWasCancelled {\n        t.Error("Expected job to be cancelled")\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-with-test-servers",children:"Testing with Test Servers"}),"\n",(0,s.jsx)(n.h3,{id:"creating-test-specific-servers",children:"Creating Test-Specific Servers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "sync"\n    "time"\n\n    "github.com/Kingson4Wu/saturncli/server"\n    "github.com/Kingson4Wu/saturncli/utils"\n)\n\ntype TestServer struct {\n    socketPath string\n    server     *server.ser\n    started    chan bool\n    wg         sync.WaitGroup\n}\n\nfunc NewTestServer(socketPath string) *TestServer {\n    return &TestServer{\n        socketPath: socketPath,\n        started:    make(chan bool),\n    }\n}\n\nfunc (ts *TestServer) Start() {\n    ts.wg.Add(1)\n    go func() {\n        defer ts.wg.Done()\n        ts.started <- true\n        ts.server = server.NewServer(&utils.DefaultLogger{}, ts.socketPath)\n        ts.server.Serve()\n    }()\n    \n    // Wait for server to indicate it\'s started\n    <-ts.started\n    // Give it a moment to fully initialize\n    time.Sleep(50 * time.Millisecond)\n}\n\nfunc (ts *TestServer) Stop() {\n    // In tests, we usually just let the process end\n    // For more sophisticated cleanup, you might need signal handling\n    ts.wg.Wait()\n}\n\nfunc (ts *TestServer) RegisterJob(name string, handler server.JobHandler) error {\n    return server.AddJob(name, handler)\n}\n\nfunc (ts *TestServer) RegisterStoppableJob(name string, handler server.StoppableJobHandler) error {\n    return server.AddStoppableJob(name, handler)\n}\n\n// Example usage in test\nfunc TestWithTestServer(t *testing.T) {\n    testServer := NewTestServer("/tmp/test_with_server.sock")\n    \n    // Register test jobs\n    jobExecuted := make(chan bool, 1)\n    testServer.RegisterJob("test-job", func(args map[string]string, signature string) bool {\n        jobExecuted <- true\n        return true\n    })\n    \n    testServer.Start()\n    \n    // Now test using the server\n    // ... test code here\n    \n    // Verify expectations\n    select {\n    case <-jobExecuted:\n        // Success\n    case <-time.After(1 * time.Second):\n        t.Error("Test job was not executed in time")\n    }\n    \n    testServer.Stop()\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-error-conditions",children:"Testing Error Conditions"}),"\n",(0,s.jsx)(n.h3,{id:"testing-error-handling",children:"Testing Error Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'func TestJobErrorHandling(t *testing.T) {\n    tests := []struct {\n        name          string\n        args          map[string]string\n        expectedError bool\n    }{\n        {\n            name:          "missing required parameter",\n            args:          map[string]string{},\n            expectedError: true, // Assuming the job returns false for missing params\n        },\n        {\n            name: "with required parameter",\n            args: map[string]string{\n                "required": "value",\n            },\n            expectedError: false,\n        },\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            result := jobThatValidatesArgs(tt.args, "test-sig")\n            \n            if tt.expectedError && result {\n                t.Error("Expected job to fail but it succeeded")\n            }\n            if !tt.expectedError && !result {\n                t.Error("Expected job to succeed but it failed")\n            }\n        })\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-testing",children:"Performance Testing"}),"\n",(0,s.jsx)(n.h3,{id:"benchmarking-jobs",children:"Benchmarking Jobs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// benchmark_test.go\npackage main\n\nimport (\n    "testing"\n)\n\nfunc BenchmarkSimpleJob(b *testing.B) {\n    args := map[string]string{\n        "test": "value",\n    }\n    \n    b.ResetTimer()\n    for i := 0; i < b.N; i++ {\n        _ = simpleJob(args, "benchmark-sig")\n    }\n}\n\nfunc BenchmarkStoppableJob(b *testing.B) {\n    b.ResetTimer()\n    for i := 0; i < b.N; i++ {\n        quit := make(chan struct{})\n        done := make(chan bool, 1)\n        \n        go func() {\n            result := fastStoppableJob(map[string]string{}, "benchmark-sig", quit)\n            done <- result\n        }()\n        \n        close(quit)\n        <-done\n    }\n}\n\nfunc BenchmarkConcurrentJobs(b *testing.B) {\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            result := simpleJob(map[string]string{}, "parallel-sig")\n            if !result {\n                b.Error("Job failed in parallel benchmark")\n            }\n        }\n    })\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"memory-profiling",children:"Memory Profiling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// Use Go\'s built-in memory profiling\nfunc TestMemoryUsage(t *testing.T) {\n    // This test can be run with memory profiling:\n    // go test -memprofile=mem.prof -run=TestMemoryUsage\n    // go tool pprof mem.prof\n    \n    // Simulate work that might use memory\n    for i := 0; i < 1000; i++ {\n        result := processLargeData()\n        if result == nil {\n            t.Errorf("Result was nil at iteration %d", i)\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-utilities-and-helpers",children:"Testing Utilities and Helpers"}),"\n",(0,s.jsx)(n.h3,{id:"test-helpers",children:"Test Helpers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "sync"\n    "time"\n)\n\n// TestJobTracker helps track job execution for testing\ntype TestJobTracker struct {\n    executedJobs map[string][]map[string]string\n    mu          sync.Mutex\n    executionCount map[string]int\n}\n\nfunc NewTestJobTracker() *TestJobTracker {\n    return &TestJobTracker{\n        executedJobs:   make(map[string][]map[string]string),\n        executionCount: make(map[string]int),\n    }\n}\n\nfunc (tjt *TestJobTracker) TrackExecution(jobName string, args map[string]string) {\n    tjt.mu.Lock()\n    defer tjt.mu.Unlock()\n    \n    tjt.executedJobs[jobName] = append(tjt.executedJobs[jobName], args)\n    tjt.executionCount[jobName]++\n}\n\nfunc (tjt *TestJobTracker) GetExecutionCount(jobName string) int {\n    tjt.mu.Lock()\n    defer tjt.mu.Unlock()\n    \n    return tjt.executionCount[jobName]\n}\n\nfunc (tjt *TestJobTracker) GetExecutions(jobName string) []map[string]string {\n    tjt.mu.Lock()\n    defer tjt.mu.Unlock()\n    \n    executions := make([]map[string]string, len(tjt.executedJobs[jobName]))\n    copy(executions, tjt.executedJobs[jobName])\n    return executions\n}\n\n// Example of using the tracker\nfunc testableJob(tracker *TestJobTracker, args map[string]string, signature string) bool {\n    tracker.TrackExecution("testable-job", args)\n    \n    // Do actual work\n    return true\n}\n\nfunc TestJobWithTracker(t *testing.T) {\n    tracker := NewTestJobTracker()\n    \n    // Run job multiple times\n    for i := 0; i < 5; i++ {\n        args := map[string]string{"iteration": string(rune(i + \'0\'))}\n        result := testableJob(tracker, args, "test-sig")\n        if !result {\n            t.Errorf("Job failed on iteration %d", i)\n        }\n    }\n    \n    // Verify tracking worked\n    if count := tracker.GetExecutionCount("testable-job"); count != 5 {\n        t.Errorf("Expected 5 executions, got %d", count)\n    }\n    \n    executions := tracker.GetExecutions("testable-job")\n    if len(executions) != 5 {\n        t.Errorf("Expected 5 executions recorded, got %d", len(executions))\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"continuous-testing",children:"Continuous Testing"}),"\n",(0,s.jsx)(n.h3,{id:"test-organization-and-running",children:"Test Organization and Running"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Run all tests\ngo test ./...\n\n# Run tests in verbose mode\ngo test -v ./...\n\n# Run with race detection (important for concurrent code)\ngo test -race ./...\n\n# Run specific test package\ngo test ./server/... -v\n\n# Run specific test\ngo test -run TestClientServerIntegration -v\n\n# Run tests with coverage\ngo test -cover ./...\n\n# Run tests with detailed coverage\ngo test -coverpkg=./... -coverprofile=coverage.out ./...\ngo tool cover -html=coverage.out -o coverage.html\n"})}),"\n",(0,s.jsx)(n.h3,{id:"test-environment-setup",children:"Test Environment Setup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// Use build tags for test-specific setup\n//go:build test\n// +build test\n\npackage main\n\nimport (\n    "os"\n    "path/filepath"\n    "testing"\n)\n\nvar testTempDir string\n\nfunc TestMain(m *testing.M) {\n    // Setup\n    var err error\n    testTempDir, err = os.MkdirTemp("", "saturn-test-*")\n    if err != nil {\n        panic(err)\n    }\n    \n    // Run tests\n    exitCode := m.Run()\n    \n    // Teardown\n    os.RemoveAll(testTempDir)\n    \n    os.Exit(exitCode)\n}\n\nfunc getTestSocketPath(name string) string {\n    return filepath.Join(testTempDir, name+".sock")\n}\n\nfunc TestWithTempSockets(t *testing.T) {\n    socketPath := getTestSocketPath("my-test")\n    \n    // Use socketPath for test server\n    // ... test code here\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-best-practices",children:"Testing Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"what-to-test",children:"What to Test"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Happy Path"}),": Normal operation scenarios"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Conditions"}),": Invalid inputs, resource failures"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Edge Cases"}),": Empty inputs, maximum values, boundary conditions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Concurrent Access"}),": Multiple clients accessing server simultaneously"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cancellation"}),": Proper stoppable job behavior"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Cleanup"}),": Proper handling of resources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameter Validation"}),": All parameter validation logic"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"what-not-to-test",children:"What NOT to Test"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implementation Details"}),": Focus on behavior, not internal implementation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Third-party Dependencies"}),": Mock external services"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Timing-Dependent Code"}),": Use channels and synchronization instead"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Non-Deterministic Behavior"}),": Ensure tests are repeatable"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"test-naming-conventions",children:"Test Naming Conventions"}),"\n",(0,s.jsxs)(n.p,{children:["Follow the pattern: ",(0,s.jsx)(n.code,{children:"Test[Feature][Scenario][ExpectedResult]"})]}),"\n",(0,s.jsx)(n.p,{children:"Examples:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"TestJobRegistrationSuccess"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"TestStoppableJobStop"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"TestJobWithInvalidParamsFails"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"TestConcurrentJobExecution"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting-tests",children:"Troubleshooting Tests"}),"\n",(0,s.jsx)(n.h3,{id:"common-testing-issues",children:"Common Testing Issues"}),"\n",(0,s.jsx)(n.h4,{id:"flaky-tests",children:"Flaky Tests"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// Fix timing-dependent tests with proper synchronization\nfunc TestJobWithWait(t *testing.T) {\n    done := make(chan bool, 1)\n    \n    go func() {\n        result := slowJob()\n        done <- result\n    }()\n    \n    select {\n    case result := <-done:\n        if !result {\n            t.Error("Job failed")\n        }\n    case <-time.After(5 * time.Second): // Reasonable timeout\n        t.Error("Job did not complete in time")\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"resource-conflicts",children:"Resource Conflicts"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// Use unique resources per test\nfunc getUniqueSocketPath(t *testing.T) string {\n    return fmt.Sprintf("/tmp/test-%s.sock", t.Name())\n}\n\nfunc TestUniqueResources(t *testing.T) {\n    socketPath := getUniqueSocketPath(t)\n    \n    // Now each test has its own socket path\n    // ... test code\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Review the ",(0,s.jsx)(n.a,{href:"/saturncli/docs/development-setup",children:"Development Setup"})," guide for environment configuration"]}),"\n",(0,s.jsxs)(n.li,{children:["Check the ",(0,s.jsx)(n.a,{href:"/saturncli/docs/architecture",children:"Architecture"})," documentation for system understanding"]}),"\n",(0,s.jsxs)(n.li,{children:["Look at the ",(0,s.jsx)(n.a,{href:"/saturncli/docs/best-practices",children:"Best Practices"})," guide for quality testing patterns"]}),"\n",(0,s.jsxs)(n.li,{children:["Follow the ",(0,s.jsx)(n.a,{href:"/saturncli/docs/contributing",children:"Contributing"})," guidelines if contributing code"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(6540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);