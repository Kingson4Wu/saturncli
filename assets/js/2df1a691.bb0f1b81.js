"use strict";(globalThis.webpackChunksaturn_cli_docs=globalThis.webpackChunksaturn_cli_docs||[]).push([[797],{5607:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"embedding","title":"Embedding Guide - Integrate Saturn CLI into Go Services","description":"Complete guide on embedding Saturn CLI into existing Go services. Learn integration patterns and best practices for seamless job execution in your applications.","source":"@site/docs/embedding.md","sourceDirName":".","slug":"/embedding","permalink":"/saturncli/docs/embedding","draft":false,"unlisted":false,"editUrl":"https://github.com/Kingson4Wu/saturncli/tree/main/documentation/docs/embedding.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Embedding Guide - Integrate Saturn CLI into Go Services","description":"Complete guide on embedding Saturn CLI into existing Go services. Learn integration patterns and best practices for seamless job execution in your applications.","keywords":["saturn cli embedding","embed go cli","integrate saturn cli","go service integration","embed job execution","saturn cli integration"]},"sidebar":"tutorialSidebar","previous":{"title":"CLI Reference - Saturn Command Line Interface Guide","permalink":"/saturncli/docs/cli-reference"},"next":{"title":"Saturn CLI Examples - Real World Go Job Execution Use Cases","permalink":"/saturncli/docs/examples"}}');var i=r(4848),s=r(8453);const o={sidebar_position:6,title:"Embedding Guide - Integrate Saturn CLI into Go Services",description:"Complete guide on embedding Saturn CLI into existing Go services. Learn integration patterns and best practices for seamless job execution in your applications.",keywords:["saturn cli embedding","embed go cli","integrate saturn cli","go service integration","embed job execution","saturn cli integration"]},a="Embedding Guide",c={},l=[{value:"Why Embed Saturn CLI?",id:"why-embed-saturn-cli",level:2},{value:"Basic Integration Pattern",id:"basic-integration-pattern",level:2},{value:"1. Service Integration Template",id:"1-service-integration-template",level:3},{value:"Advanced Integration Patterns",id:"advanced-integration-patterns",level:2},{value:"Pattern 1: Job Factory with Configuration",id:"pattern-1-job-factory-with-configuration",level:3},{value:"Pattern 2: Service Container with Multiple Saturn Instances",id:"pattern-2-service-container-with-multiple-saturn-instances",level:3},{value:"Configuration Management",id:"configuration-management",level:2},{value:"Environment-Based Configuration",id:"environment-based-configuration",level:3},{value:"Logging and Monitoring",id:"logging-and-monitoring",level:2},{value:"Custom Logger Integration",id:"custom-logger-integration",level:3},{value:"Testing Embedded Saturn",id:"testing-embedded-saturn",level:2},{value:"Unit Testing Job Handlers",id:"unit-testing-job-handlers",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Socket Permissions",id:"socket-permissions",level:3},{value:"Parameter Validation Example",id:"parameter-validation-example",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Connection Pooling for Clients",id:"connection-pooling-for-clients",level:3},{value:"Migration Strategies",id:"migration-strategies",level:2},{value:"Version Management",id:"version-management",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"Next Steps",id:"next-steps",level:2}];function g(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"embedding-guide",children:"Embedding Guide"})}),"\n",(0,i.jsx)(n.p,{children:"Saturn CLI is designed to be embedded directly into your existing services. This guide provides patterns and best practices for seamless integration of job execution capabilities into your Go applications."}),"\n",(0,i.jsx)(n.h2,{id:"why-embed-saturn-cli",children:"Why Embed Saturn CLI?"}),"\n",(0,i.jsx)(n.p,{children:"Saturn CLI excels at scenarios where you need to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Execute shell-style commands as background jobs"}),"\n",(0,i.jsx)(n.li,{children:"Integrate external tools with your Go services"}),"\n",(0,i.jsx)(n.li,{children:"Provide job scheduling capabilities to your applications"}),"\n",(0,i.jsx)(n.li,{children:"Enable graceful cancellation of long-running tasks"}),"\n",(0,i.jsx)(n.li,{children:"Maintain fast, secure communication channels with background workers"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"basic-integration-pattern",children:"Basic Integration Pattern"}),"\n",(0,i.jsx)(n.p,{children:"Here's the recommended pattern for embedding Saturn CLI into your services:"}),"\n",(0,i.jsx)(n.h3,{id:"1-service-integration-template",children:"1. Service Integration Template"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "context"\n    "log"\n    "sync"\n\n    "github.com/Kingson4Wu/saturncli/server"\n    "github.com/Kingson4Wu/saturncli/utils"\n)\n\n// MyService demonstrates how to embed Saturn CLI into an existing service\ntype MyService struct {\n    server   *server.ser\n    registry *server.Registry\n    logger   utils.Logger\n    wg       sync.WaitGroup\n    ctx      context.Context\n    cancel   context.CancelFunc\n}\n\nfunc NewMyService(logger utils.Logger) *MyService {\n    ctx, cancel := context.WithCancel(context.Background())\n    \n    service := &MyService{\n        logger: logger,\n        ctx:    ctx,\n        cancel: cancel,\n    }\n    \n    // Create a dedicated registry for this service\n    service.registry = server.NewRegistry()\n    \n    // Register jobs specific to this service\n    service.setupJobs()\n    \n    // Initialize the Saturn server\n    service.server = server.NewServer(\n        logger,\n        "/tmp/myservice_saturn.sock",  // Customize socket path\n        server.WithRegistry(service.registry),\n    )\n    \n    return service\n}\n\nfunc (s *MyService) setupJobs() {\n    // Register service-specific jobs\n    if err := s.registry.AddJob("data-processing", s.handleDataProcessing); err != nil {\n        s.logger.Errorf("Failed to register data-processing job: %v", err)\n    }\n    \n    if err := s.registry.AddStoppableJob("continuous-monitoring", s.handleContinuousMonitoring); err != nil {\n        s.logger.Errorf("Failed to register continuous-monitoring job: %v", err)\n    }\n}\n\nfunc (s *MyService) handleDataProcessing(args map[string]string, signature string) bool {\n    s.logger.Infof("Starting data processing job %s with args: %v", signature, args)\n    \n    // Extract and validate parameters\n    dataset := args["dataset"]\n    if dataset == "" {\n        s.logger.Errorf("Missing dataset parameter for job %s", signature)\n        return false\n    }\n    \n    // Simulate data processing\n    s.logger.Infof("Processing dataset: %s in job %s", dataset, signature)\n    \n    // Add your actual data processing logic here\n    // ...\n    \n    s.logger.Infof("Data processing job %s completed", signature)\n    return true\n}\n\nfunc (s *MyService) handleContinuousMonitoring(args map[string]string, signature string, quit chan struct{}) bool {\n    s.logger.Infof("Starting continuous monitoring job %s", signature)\n    \n    intervalStr := args["interval"]\n    if intervalStr == "" {\n        intervalStr = "5" // default to 5 seconds\n    }\n    \n    // Parse interval (implement proper parsing for production use)\n    // interval, _ := strconv.Atoi(intervalStr)\n    \n    // Monitoring loop that can be stopped via quit channel\n    ticker := s.newTickerWithQuit(quit, 5) // every 5 seconds\n    \n    for {\n        select {\n        case <-quit:\n            s.logger.Infof("Monitoring job %s received quit signal", signature)\n            return true\n        case <-ticker.C:\n            s.logger.Debugf("Performing monitoring check in job %s", signature)\n            // Perform monitoring activity\n            s.performHealthCheck()\n        }\n    }\n}\n\nfunc (s *MyService) newTickerWithQuit(quit chan struct{}, seconds int) *tickerWithQuit {\n    t := time.NewTicker(time.Duration(seconds) * time.Second)\n    return &tickerWithQuit{t: t, quit: quit}\n}\n\ntype tickerWithQuit struct {\n    t    *time.Ticker\n    quit chan struct{}\n}\n\nfunc (twq *tickerWithQuit) C() <-chan time.Time {\n    return twq.t.C\n}\n\nfunc (s *MyService) performHealthCheck() {\n    // Implement your health checking logic here\n    s.logger.Debugf("Health check performed")\n}\n\nfunc (s *MyService) Start() {\n    s.wg.Add(1)\n    go func() {\n        defer s.wg.Done()\n        s.logger.Info("Starting Saturn server...")\n        s.server.Serve()\n    }()\n}\n\nfunc (s *MyService) Stop() {\n    s.logger.Info("Stopping Saturn server...")\n    s.cancel() // Cancel context\n    s.wg.Wait() // Wait for goroutines to finish\n}\n\n// Client usage example\nfunc (s *MyService) TriggerDataProcessing(dataset string) error {\n    // Create a client to communicate with our own server\n    cli := client.NewClient(s.logger, "/tmp/myservice_saturn.sock")\n    \n    result := cli.Run(&client.Task{\n        Name: "data-processing",\n        Params: map[string]string{\n            "dataset": dataset,\n            "source":  "api",\n        },\n    })\n    \n    switch result {\n    case base.SUCCESS:\n        s.logger.Info("Data processing job completed successfully")\n        return nil\n    case base.FAILURE:\n        return errors.New("data processing job failed")\n    case base.INTERRUPT:\n        s.logger.Info("Data processing job was interrupted")\n        return nil\n    default:\n        return errors.New("unknown job result")\n    }\n}\n\nfunc main() {\n    service := NewMyService(&utils.DefaultLogger{})\n    \n    // Start the service\n    service.Start()\n    \n    // The server is now running and accepting job requests\n    // You can trigger jobs via client or external commands\n    \n    // Graceful shutdown example with signal handling\n    sigChan := make(chan os.Signal, 1)\n    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n    \n    <-sigChan // Wait for signal\n    log.Println("Shutting down service...")\n    \n    service.Stop()\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-integration-patterns",children:"Advanced Integration Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"pattern-1-job-factory-with-configuration",children:"Pattern 1: Job Factory with Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type JobFactory struct {\n    config Config\n    logger utils.Logger\n}\n\ntype Config struct {\n    Timeout    time.Duration\n    MaxRetries int\n    QueueSize  int\n}\n\nfunc (jf *JobFactory) CreateDatabaseBackupJob(dbConfig DBConfig) server.JobHandler {\n    return func(args map[string]string, signature string) bool {\n        jf.logger.Infof("Starting database backup %s", signature)\n        \n        ctx, cancel := context.WithTimeout(context.Background(), jf.config.Timeout)\n        defer cancel()\n        \n        // Use dbConfig to perform database backup\n        // ...\n        \n        // Log progress and handle errors appropriately\n        jf.logger.Infof("Database backup %s completed", signature)\n        return true\n    }\n}\n\nfunc (jf *JobFactory) CreateFileProcessorJob(outputDir string) server.StoppableJobHandler {\n    return func(args map[string]string, signature string, quit chan struct{}) bool {\n        jf.logger.Infof("Starting file processor %s", signature)\n        \n        // Process files with ability to quit\n        files := strings.Split(args["files"], ",")\n        \n        for i, file := range files {\n            select {\n            case <-quit:\n                jf.logger.Infof("File processor %s stopped at file %d", signature, i)\n                return true\n            default:\n                // Process individual file\n                jf.processFile(file, signature)\n            }\n        }\n        \n        jf.logger.Infof("File processor %s completed", signature)\n        return true\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-2-service-container-with-multiple-saturn-instances",children:"Pattern 2: Service Container with Multiple Saturn Instances"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type ServiceContainer struct {\n    apiServer     *http.Server\n    jobServer     *server.ser\n    notificationSrv *server.ser\n    logger        utils.Logger\n    cancel        context.CancelFunc\n}\n\nfunc NewServiceContainer(config ServiceConfig) *ServiceContainer {\n    ctx, cancel := context.WithCancel(context.Background())\n    \n    container := &ServiceContainer{\n        logger: &utils.DefaultLogger{},\n        cancel: cancel,\n    }\n    \n    // Create separate Saturn servers for different purposes\n    container.jobServer = container.createJobServer(config.JobSocketPath)\n    container.notificationSrv = container.createNotificationServer(config.NotificationSocketPath)\n    \n    return container\n}\n\nfunc (sc *ServiceContainer) createJobServer(socketPath string) *server.ser {\n    registry := server.NewRegistry()\n    \n    // Register job-specific handlers\n    registry.AddJob("batch-process", sc.handleBatchProcess)\n    registry.AddStoppableJob("monitor-resources", sc.handleResourceMonitoring)\n    \n    return server.NewServer(sc.logger, socketPath, server.WithRegistry(registry))\n}\n\nfunc (sc *ServiceContainer) createNotificationServer(socketPath string) *server.ser {\n    registry := server.NewRegistry()\n    \n    // Register notification-specific handlers\n    registry.AddJob("send-email", sc.handleSendEmail)\n    registry.AddJob("push-notification", sc.handlePushNotification)\n    \n    return server.NewServer(sc.logger, socketPath, server.WithRegistry(registry))\n}\n\nfunc (sc *ServiceContainer) Start() {\n    go sc.jobServer.Serve()\n    go sc.notificationSrv.Serve()\n    // Start other services...\n}\n\nfunc (sc *ServiceContainer) Stop() {\n    sc.cancel()\n    // Close servers gracefully\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"configuration-management",children:"Configuration Management"}),"\n",(0,i.jsx)(n.h3,{id:"environment-based-configuration",children:"Environment-Based Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type SaturnConfig struct {\n    SocketPath    string\n    JobTimeout    time.Duration\n    MaxWorkers    int\n    EnableMetrics bool\n}\n\nfunc LoadSaturnConfigFromEnv() SaturnConfig {\n    return SaturnConfig{\n        SocketPath:    getEnvOrDefault("SATURN_SOCKET_PATH", "/tmp/saturn.sock"),\n        JobTimeout:    parseDurationEnv("SATURN_JOB_TIMEOUT", 5*time.Minute),\n        MaxWorkers:    parseIntEnv("SATURN_MAX_WORKERS", 10),\n        EnableMetrics: parseBoolEnv("SATURN_ENABLE_METRICS", true),\n    }\n}\n\nfunc ApplyConfigToServer(server *server.ser, config SaturnConfig) {\n    // Apply configuration to server - this is conceptual,\n    // real implementation would depend on Saturn\'s configuration API\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"logging-and-monitoring",children:"Logging and Monitoring"}),"\n",(0,i.jsx)(n.h3,{id:"custom-logger-integration",children:"Custom Logger Integration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// Example of integrating with a structured logger like logrus\ntype LogrusAdapter struct {\n    logger *logrus.Logger\n}\n\nfunc (l *LogrusAdapter) Info(msg string) {\n    l.logger.Info(msg)\n}\n\nfunc (l *LogrusAdapter) Infof(format string, args ...interface{}) {\n    l.logger.Infof(format, args...)\n}\n\nfunc (l *LogrusAdapter) Error(msg string) {\n    l.logger.Error(msg)\n}\n\nfunc (l *LogrusAdapter) Errorf(format string, args ...interface{}) {\n    l.logger.Errorf(format, args...)\n}\n\nfunc (l *LogrusAdapter) Warn(msg string) {\n    l.logger.Warn(msg)\n}\n\nfunc (l *LogrusAdapter) Warnf(format string, args ...interface{}) {\n    l.logger.Warnf(format, args...)\n}\n\nfunc (l *LogrusAdapter) Debug(msg string) {\n    l.logger.Debug(msg)\n}\n\nfunc (l *LogrusAdapter) Debugf(format string, args ...interface{}) {\n    l.logger.Debugf(format, args...)\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-embedded-saturn",children:"Testing Embedded Saturn"}),"\n",(0,i.jsx)(n.h3,{id:"unit-testing-job-handlers",children:"Unit Testing Job Handlers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func TestMyJobHandler(t *testing.T) {\n    // Mock logger for testing\n    var logBuffer bytes.Buffer\n    mockLogger := &TestLogger{writer: &logBuffer}\n    \n    // Test data\n    args := map[string]string{\n        "input": "test_data",\n        "param": "value",\n    }\n    \n    // Create handler\n    handler := createMyJobHandler(mockLogger)\n    \n    // Execute handler\n    result := handler(args, "test_signature")\n    \n    // Assertions\n    if !result {\n        t.Error("Expected job to succeed")\n    }\n    \n    // Verify log output\n    if !strings.Contains(logBuffer.String(), "expected log message") {\n        t.Error("Expected log message not found")\n    }\n}\n\nfunc TestStoppableJobHandler(t *testing.T) {\n    // Similar test for stoppable job with quit channel\n    quit := make(chan struct{})\n    args := map[string]string{"test": "value"}\n    \n    // Use a timeout to avoid hanging tests\n    done := make(chan bool)\n    \n    go func() {\n        result := myStoppableHandler(args, "test_sig", quit)\n        done <- result\n    }()\n    \n    // Close quit channel after a delay to test stopping behavior\n    time.Sleep(100 * time.Millisecond)\n    close(quit)\n    \n    select {\n    case result := <-done:\n        // Verify that the job handled the quit signal correctly\n        if !result {\n            t.Error("Expected job to return true after stopping")\n        }\n    case <-time.After(1 * time.Second):\n        t.Error("Test timed out - job didn\'t respond to quit signal")\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"socket-permissions",children:"Socket Permissions"}),"\n",(0,i.jsx)(n.p,{children:"When deploying in production, consider the following security aspects:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Socket File Permissions"}),": Restrict socket file access to authorized processes only"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameter Validation"}),": Always validate parameters passed to job handlers to prevent injection attacks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Timeout Enforcement"}),": Implement timeouts in job handlers to prevent resource exhaustion"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource Limits"}),": Limit resource consumption (memory, disk, CPU) within job handlers"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"parameter-validation-example",children:"Parameter Validation Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func validateJobParameters(args map[string]string) error {\n    // Validate that all required params are present\n    for _, required := range []string{"input", "output"} {\n        if args[required] == "" {\n            return fmt.Errorf("missing required parameter: %s", required)\n        }\n    }\n    \n    // Sanitize input parameters to prevent command injection\n    for key, value := range args {\n        if strings.Contains(value, "../") || strings.Contains(value, "..\\\\") {\n            return fmt.Errorf("unsafe path parameter detected in %s: %s", key, value)\n        }\n        \n        // Additional validation based on parameter meaning\n        // ...\n    }\n    \n    return nil\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(n.h3,{id:"connection-pooling-for-clients",children:"Connection Pooling for Clients"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"type ClientPool struct {\n    mu    sync.RWMutex\n    pool  []*client.cli\n    max   int\n    count int\n    factory func() *client.cli\n}\n\nfunc NewClientPool(maxClients int, factory func() *client.cli) *ClientPool {\n    return &ClientPool{\n        max:     maxClients,\n        factory: factory,\n    }\n}\n\nfunc (cp *ClientPool) GetClient() *client.cli {\n    cp.mu.Lock()\n    defer cp.mu.Unlock()\n    \n    if cp.count < cp.max && len(cp.pool) == 0 {\n        cp.count++\n        return cp.factory()\n    }\n    \n    if len(cp.pool) > 0 {\n        client := cp.pool[len(cp.pool)-1]\n        cp.pool = cp.pool[:len(cp.pool)-1]\n        return client\n    }\n    \n    // Block until a client becomes available\n    // In practice, you might want to implement a timeout\n    for len(cp.pool) == 0 {\n        cp.mu.Unlock()\n        time.Sleep(10 * time.Millisecond)\n        cp.mu.Lock()\n    }\n    \n    client := cp.pool[len(cp.pool)-1]\n    cp.pool = cp.pool[:len(cp.pool)-1]\n    return client\n}\n\nfunc (cp *ClientPool) ReturnClient(cli *client.cli) {\n    cp.mu.Lock()\n    defer cp.mu.Unlock()\n    \n    if len(cp.pool) < cp.max {\n        cp.pool = append(cp.pool, cli)\n    } else {\n        // Pool is full, discard the extra client\n        cp.count--\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"migration-strategies",children:"Migration Strategies"}),"\n",(0,i.jsx)(n.h3,{id:"version-management",children:"Version Management"}),"\n",(0,i.jsx)(n.p,{children:"When upgrading Saturn CLI in your services:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Deploy Gradually"}),": Roll out Saturn updates to subsets of your service fleet"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Maintain Compatibility"}),": Ensure older clients can communicate with newer servers during transition periods"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Monitor Metrics"}),": Track job execution times, success rates, and error patterns"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Version Pinning"}),": In production environments, pin specific Saturn versions to ensure stability"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsx)(n.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Socket Permission Errors"}),": Ensure your service has appropriate permissions to create socket files in the specified directory"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Job Timeouts"}),": Increase timeout values or optimize job implementation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory Leaks"}),": Monitor for unreleased resources in job handlers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Connection Failures"}),": Verify socket paths and ensure server is running"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Review the ",(0,i.jsx)(n.a,{href:"/saturncli/docs/architecture",children:"Architecture"})," documentation to understand system design"]}),"\n",(0,i.jsxs)(n.li,{children:["Check out ",(0,i.jsx)(n.a,{href:"/saturncli/docs/examples",children:"Examples"})," for real-world usage patterns"]}),"\n",(0,i.jsxs)(n.li,{children:["Consult the ",(0,i.jsx)(n.a,{href:"/saturncli/docs/client-api",children:"Client API"})," and ",(0,i.jsx)(n.a,{href:"/saturncli/docs/server-api",children:"Server API"})," references for detailed method information"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(6540);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);