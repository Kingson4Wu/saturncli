"use strict";(globalThis.webpackChunksaturn_cli_docs=globalThis.webpackChunksaturn_cli_docs||[]).push([[483],{2975:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"best-practices","title":"Best Practices - Optimal Saturn CLI Usage for Go Applications","description":"Recommended practices for using Saturn CLI effectively, safely, and efficiently in your Go applications. Optimize job execution and inter-process communication.","source":"@site/docs/best-practices.md","sourceDirName":".","slug":"/best-practices","permalink":"/saturncli/docs/best-practices","draft":false,"unlisted":false,"editUrl":"https://github.com/Kingson4Wu/saturncli/tree/main/documentation/docs/best-practices.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"title":"Best Practices - Optimal Saturn CLI Usage for Go Applications","description":"Recommended practices for using Saturn CLI effectively, safely, and efficiently in your Go applications. Optimize job execution and inter-process communication.","keywords":["saturn cli best practices","go cli best practices","job execution best practices","unix domain sockets best practices","golang cli optimization"]},"sidebar":"tutorialSidebar","previous":{"title":"Troubleshooting Saturn CLI - Common Issues & Solutions","permalink":"/saturncli/docs/troubleshooting"},"next":{"title":"Contributing to Saturn CLI - Development & Contribution Guide","permalink":"/saturncli/docs/contributing"}}');var t=r(4848),s=r(8453);const a={sidebar_position:10,title:"Best Practices - Optimal Saturn CLI Usage for Go Applications",description:"Recommended practices for using Saturn CLI effectively, safely, and efficiently in your Go applications. Optimize job execution and inter-process communication.",keywords:["saturn cli best practices","go cli best practices","job execution best practices","unix domain sockets best practices","golang cli optimization"]},o="Best Practices",c={},l=[{value:"Job Design Patterns",id:"job-design-patterns",level:2},{value:"Creating Well-Behaved Jobs",id:"creating-well-behaved-jobs",level:3},{value:"Stoppable Job Patterns",id:"stoppable-job-patterns",level:3},{value:"Parameter Handling",id:"parameter-handling",level:2},{value:"Secure Parameter Processing",id:"secure-parameter-processing",level:3},{value:"Error Handling and Resilience",id:"error-handling-and-resilience",level:2},{value:"Comprehensive Error Handling",id:"comprehensive-error-handling",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Efficient Resource Usage",id:"efficient-resource-usage",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Secure Job Implementation",id:"secure-job-implementation",level:3},{value:"Logging and Monitoring",id:"logging-and-monitoring",level:2},{value:"Effective Logging Practices",id:"effective-logging-practices",level:3},{value:"Testing and Verification",id:"testing-and-verification",level:2},{value:"Writing Testable Jobs",id:"writing-testable-jobs",level:3},{value:"Integration Patterns",id:"integration-patterns",level:2},{value:"Service Integration Best Practices",id:"service-integration-best-practices",level:3},{value:"Common Anti-Patterns to Avoid",id:"common-anti-patterns-to-avoid",level:2},{value:"What NOT to Do",id:"what-not-to-do",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:2},{value:"Observability Best Practices",id:"observability-best-practices",level:3},{value:"Next Steps",id:"next-steps",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"best-practices",children:"Best Practices"})}),"\n",(0,t.jsx)(n.p,{children:"This guide provides recommended practices for using Saturn CLI effectively, safely, and efficiently in your Go applications for optimal job execution and process management."}),"\n",(0,t.jsx)(n.h2,{id:"job-design-patterns",children:"Job Design Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"creating-well-behaved-jobs",children:"Creating Well-Behaved Jobs"}),"\n",(0,t.jsx)(n.p,{children:"Design your jobs to be predictable, reliable, and safe:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func wellBehavedJob(args map[string]string, signature string) bool {\n    // 1. Validate inputs first\n    if args["required_param"] == "" {\n        log.Printf("[%s] Missing required parameter", signature)\n        return false\n    }\n    \n    // 2. Handle resources properly with defer\n    resource, err := obtainResource(args["resource_id"])\n    if err != nil {\n        log.Printf("[%s] Failed to obtain resource: %v", signature, err)\n        return false\n    }\n    defer resource.Close() // Always cleanup\n    \n    // 3. Do the actual work\n    success := doWork(resource, args)\n    \n    // 4. Log completion status\n    if success {\n        log.Printf("[%s] Job completed successfully", signature)\n    } else {\n        log.Printf("[%s] Job failed", signature)\n    }\n    \n    return success\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"stoppable-job-patterns",children:"Stoppable Job Patterns"}),"\n",(0,t.jsx)(n.p,{children:"For long-running jobs that need cancellation support:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func goodStoppableJob(args map[string]string, signature string, quit chan struct{}) bool {\n    log.Printf("[%s] Starting stoppable job", signature)\n    \n    // 1. Break work into small, interruptible chunks\n    for i := 0; ; i++ {\n        select {\n        case <-quit:\n            log.Printf("[%s] Job stopped at iteration %d", signature, i)\n            return true // Return true for successful cancellation\n        default:\n            // 2. Do small amount of work\n            if err := doSmallWorkChunk(i); err != nil {\n                log.Printf("[%s] Error in work chunk %d: %v", signature, i, err)\n                return false\n            }\n            \n            // 3. Yield periodically to check quit channel\n            time.Sleep(100 * time.Millisecond)\n        }\n    }\n}\n\n// Better version using ticker for more consistent intervals\nfunc betterStoppableJob(args map[string]string, signature string, quit chan struct{}) bool {\n    ticker := time.NewTicker(100 * time.Millisecond)\n    defer ticker.Stop()\n    \n    for i := 0; ; i++ {\n        select {\n        case <-quit:\n            log.Printf("[%s] Job stopped at iteration %d", signature, i)\n            return true\n        case <-ticker.C:\n            // Do work for this interval\n            if err := doWorkForInterval(i); err != nil {\n                log.Printf("[%s] Error: %v", signature, err)\n                return false\n            }\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"parameter-handling",children:"Parameter Handling"}),"\n",(0,t.jsx)(n.h3,{id:"secure-parameter-processing",children:"Secure Parameter Processing"}),"\n",(0,t.jsx)(n.p,{children:"Always validate and sanitize parameters to prevent injection attacks:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func secureJob(args map[string]string, signature string) bool {\n    // 1. Validate all parameters\n    if !validateParameters(args) {\n        log.Printf("[%s] Invalid parameters provided", signature)\n        return false\n    }\n    \n    // 2. Sanitize parameters before use\n    filename := sanitizeFilename(args["filename"])\n    if filename == "" {\n        log.Printf("[%s] Invalid filename after sanitization", signature)\n        return false\n    }\n    \n    // 3. Use parameters safely\n    data, err := readSafeFile(filename)\n    if err != nil {\n        log.Printf("[%s] Error reading file: %v", signature, err)\n        return false\n    }\n    \n    return processData(data)\n}\n\nfunc validateParameters(args map[string]string) bool {\n    // Check required parameters\n    required := []string{"user_id", "action"}\n    for _, param := range required {\n        if args[param] == "" {\n            return false\n        }\n    }\n    \n    // Validate parameter formats\n    if !isValidUserID(args["user_id"]) {\n        return false\n    }\n    \n    return true\n}\n\nfunc sanitizeFilename(filename string) string {\n    // Prevent directory traversal\n    if strings.Contains(filename, "../") || strings.Contains(filename, "..\\\\") {\n        return ""\n    }\n    \n    // Only allow safe characters\n    if !regexp.MustCompile(`^[a-zA-Z0-9._-]+$`).MatchString(filename) {\n        return ""\n    }\n    \n    return filepath.Clean(filename)\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling-and-resilience",children:"Error Handling and Resilience"}),"\n",(0,t.jsx)(n.h3,{id:"comprehensive-error-handling",children:"Comprehensive Error Handling"}),"\n",(0,t.jsx)(n.p,{children:"Structure your jobs with proper error handling at every level:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func resilientJob(args map[string]string, signature string, quit chan struct{}) bool {\n    // 1. Input validation\n    if err := validateJobArgs(args); err != nil {\n        log.Printf("[%s] Input validation failed: %v", signature, err)\n        return false\n    }\n    \n    // 2. Resource acquisition with retry\n    var resource *MyResource\n    for attempt := 0; attempt < 3; attempt++ {\n        select {\n        case <-quit:\n            return true\n        default:\n            var err error\n            resource, err = acquireResource(args["resource_id"])\n            if err == nil {\n                break\n            }\n            log.Printf("[%s] Resource acquisition failed (attempt %d): %v", \n                      signature, attempt+1, err)\n            time.Sleep(time.Duration(attempt+1) * time.Second)\n        }\n    }\n    \n    if resource == nil {\n        log.Printf("[%s] Failed to acquire resource after retries", signature)\n        return false\n    }\n    defer resource.Close()\n    \n    // 3. Main work with progress tracking\n    totalWork := extractTotalWork(args)\n    for i := 0; i < totalWork; i++ {\n        select {\n        case <-quit:\n            log.Printf("[%s] Job cancelled at %d/%d", signature, i, totalWork)\n            return true\n        default:\n            if err := doWorkUnit(resource, i); err != nil {\n                log.Printf("[%s] Work unit %d failed: %v", signature, i, err)\n                \n                // Decide whether to continue or fail based on error type\n                if isFatalError(err) {\n                    return false\n                }\n                // For non-fatal errors, continue\n            }\n            \n            // Track progress\n            if i%10 == 0 { // Log every 10 units\n                log.Printf("[%s] Progress: %d/%d", signature, i, totalWork)\n            }\n        }\n    }\n    \n    log.Printf("[%s] Job completed successfully", signature)\n    return true\n}\n\nfunc isFatalError(err error) bool {\n    // Define which errors are fatal vs retryable\n    return errors.Is(err, ErrInvalidData) || errors.Is(err, ErrPermissionDenied)\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsx)(n.h3,{id:"efficient-resource-usage",children:"Efficient Resource Usage"}),"\n",(0,t.jsx)(n.p,{children:"Optimize for memory, CPU, and I/O efficiency:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func efficientJob(args map[string]string, signature string, quit chan struct{}) bool {\n    // 1. Pre-allocate slices when possible\n    expectedCount := extractExpectedCount(args)\n    results := make([]string, 0, expectedCount)\n    \n    // 2. Process in batches to limit memory usage\n    batchSize := 100\n    for start := 0; start < expectedCount; start += batchSize {\n        select {\n        case <-quit:\n            return true\n        default:\n            // Process batch\n            batchEnd := start + batchSize\n            if batchEnd > expectedCount {\n                batchEnd = expectedCount\n            }\n            \n            batchResults, err := processBatch(start, batchEnd)\n            if err != nil {\n                log.Printf("[%s] Batch %d-%d failed: %v", signature, start, batchEnd, err)\n                return false\n            }\n            \n            results = append(results, batchResults...)\n        }\n    }\n    \n    // 3. Process results efficiently\n    return saveResults(results)\n}\n\n// 4. Use buffered I/O for file operations\nfunc processFileWithBuffering(inputPath, outputPath string) error {\n    input, err := os.Open(inputPath)\n    if err != nil {\n        return err\n    }\n    defer input.Close()\n    \n    output, err := os.Create(outputPath)\n    if err != nil {\n        return err\n    }\n    defer output.Close()\n    \n    // Use buffered reader/writer for better performance\n    reader := bufio.NewReaderSize(input, 64*1024) // 64KB buffer\n    writer := bufio.NewWriterSize(output, 64*1024) // 64KB buffer\n    \n    // Process data\n    buffer := make([]byte, 8192) // 8KB processing buffer\n    for {\n        n, err := reader.Read(buffer)\n        if n > 0 {\n            if _, writeErr := writer.Write(buffer[:n]); writeErr != nil {\n                return writeErr\n            }\n        }\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            return err\n        }\n    }\n    \n    return writer.Flush()\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,t.jsx)(n.h3,{id:"secure-job-implementation",children:"Secure Job Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Implement security best practices to protect your system:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func secureJobWithValidation(args map[string]string, signature string) bool {\n    // 1. Validate and sanitize all inputs\n    userID := args["user_id"]\n    if !isValidUserID(userID) {\n        return false\n    }\n    \n    action := args["action"]\n    if !isValidAction(action) {\n        return false\n    }\n    \n    // 2. Implement access controls\n    if !userHasPermission(userID, action) {\n        log.Printf("[%s] Access denied for user %s to perform %s", signature, userID, action)\n        return false\n    }\n    \n    // 3. Use system calls safely (if needed)\n    if action == "execute_command" {\n        command := args["command"]\n        if !isValidCommand(command) {\n            log.Printf("[%s] Invalid command: %s", signature, command)\n            return false\n        }\n        \n        // Use only safe commands, never pass user input directly\n        cmd := exec.Command("/usr/bin/safe-utility", sanitizeCommandArgs(command))\n        output, err := cmd.CombinedOutput()\n        \n        if err != nil {\n            log.Printf("[%s] Command failed: %v, output: %s", signature, err, output)\n            return false\n        }\n        \n        log.Printf("[%s] Command completed successfully", signature)\n    }\n    \n    return true\n}\n\nfunc isValidCommand(cmd string) bool {\n    // Only allow specific, safe commands\n    allowedCommands := map[string]bool{\n        "status": true,\n        "backup": true,\n        "report": true,\n    }\n    \n    return allowedCommands[cmd]\n}\n\nfunc sanitizeCommandArgs(args string) []string {\n    // Validate that command args don\'t contain dangerous shell characters\n    dangerousChars := []string{";", "&", "|", "`", "$", "(", ")", "<", ">", "*"}\n    for _, char := range dangerousChars {\n        if strings.Contains(args, char) {\n            return nil // Invalid args\n        }\n    }\n    \n    // Split and sanitize individual arguments\n    parts := strings.Fields(args)\n    sanitized := make([]string, 0, len(parts))\n    \n    for _, part := range parts {\n        // Apply further sanitization as needed\n        sanitized = append(sanitized, strings.TrimSpace(part))\n    }\n    \n    return sanitized\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"logging-and-monitoring",children:"Logging and Monitoring"}),"\n",(0,t.jsx)(n.h3,{id:"effective-logging-practices",children:"Effective Logging Practices"}),"\n",(0,t.jsx)(n.p,{children:"Implement comprehensive and useful logging:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func wellLoggedJob(args map[string]string, signature string, quit chan struct{}) bool {\n    start := time.Now()\n    log.Printf("[%s] Job started with args: %+v", signature, redactSensitiveInfo(args))\n    \n    defer func() {\n        duration := time.Since(start)\n        log.Printf("[%s] Job completed in %v", signature, duration)\n    }()\n    \n    // Use structured logging with context\n    log.Printf("[%s] Step 1: Initializing resources", signature)\n    resource, err := initializeResource()\n    if err != nil {\n        log.Printf("[%s] ERROR: Failed to initialize resource: %v", signature, err)\n        return false\n    }\n    defer func() {\n        if closeErr := resource.Close(); closeErr != nil {\n            log.Printf("[%s] WARNING: Error closing resource: %v", signature, closeErr)\n        }\n    }()\n    \n    log.Printf("[%s] Step 2: Processing main work", signature)\n    for i := 0; i < 100; i++ {\n        select {\n        case <-quit:\n            log.Printf("[%s] Job cancelled at step %d/100", signature, i)\n            return true\n        default:\n            if i%20 == 0 { // Log progress every 20%\n                progress := float64(i) / 100.0 * 100\n                log.Printf("[%s] Progress: %.1f%%", signature, progress)\n            }\n            \n            if err := processItem(i, resource); err != nil {\n                log.Printf("[%s] WARNING: Error processing item %d: %v", signature, i, err)\n                // Decide whether to continue or fail based on context\n            }\n        }\n    }\n    \n    log.Printf("[%s] Step 3: Finalizing", signature)\n    return finalizeWork(resource)\n}\n\nfunc redactSensitiveInfo(args map[string]string) map[string]string {\n    // Don\'t log sensitive information\n    safeArgs := make(map[string]string, len(args))\n    for k, v := range args {\n        switch k {\n        case "password", "token", "secret", "key":\n            safeArgs[k] = "[REDACTED]"\n        default:\n            safeArgs[k] = v\n        }\n    }\n    return safeArgs\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"testing-and-verification",children:"Testing and Verification"}),"\n",(0,t.jsx)(n.h3,{id:"writing-testable-jobs",children:"Writing Testable Jobs"}),"\n",(0,t.jsx)(n.p,{children:"Design jobs that can be easily tested and verified:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// Interface for dependencies to enable mocking\ntype ResourceProvider interface {\n    GetResource(id string) (Resource, error)\n    Close() error\n}\n\n// Make your job function configurable for testing\ntype JobConfig struct {\n    ResourceProvider ResourceProvider\n    Logger           utils.Logger\n    MaxRetries       int\n}\n\nfunc jobWithConfig(config JobConfig) server.JobHandler {\n    return func(args map[string]string, signature string) bool {\n        resource, err := config.ResourceProvider.GetResource(args["resource_id"])\n        if err != nil {\n            config.Logger.Errorf("[%s] Failed to get resource: %v", signature, err)\n            return false\n        }\n        defer config.ResourceProvider.Close()\n        \n        // ... rest of job logic using config\n        return doWorkWithResource(resource)\n    }\n}\n\n// Example unit test\nfunc TestJobWithConfig(t *testing.T) {\n    // Create mock provider\n    mockProvider := &MockResourceProvider{\n        resource: &TestResource{},\n        err:      nil,\n    }\n    \n    config := JobConfig{\n        ResourceProvider: mockProvider,\n        Logger:           &TestLogger{},\n        MaxRetries:       3,\n    }\n    \n    jobHandler := jobWithConfig(config)\n    \n    result := jobHandler(map[string]string{"resource_id": "test"}, "test-sig")\n    \n    if !result {\n        t.Error("Expected job to succeed")\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"integration-patterns",children:"Integration Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"service-integration-best-practices",children:"Service Integration Best Practices"}),"\n",(0,t.jsx)(n.p,{children:"When embedding Saturn CLI in services:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'type JobService struct {\n    server      *server.ser\n    logger      utils.Logger\n    client      *client.cli\n    initialized bool\n}\n\nfunc NewJobService(config Config) *JobService {\n    service := &JobService{\n        logger: config.Logger,\n    }\n    \n    // Register all jobs during initialization\n    if err := service.registerJobs(); err != nil {\n        service.logger.Errorf("Failed to register jobs: %v", err)\n        return nil\n    }\n    \n    // Create server with proper registry\n    service.server = server.NewServer(\n        service.logger,\n        config.SocketPath,\n        server.WithRegistry(config.Registry),\n    )\n    \n    // Create client for internal use\n    service.client = client.NewClient(service.logger, config.SocketPath)\n    \n    service.initialized = true\n    return service\n}\n\nfunc (js *JobService) registerJobs() error {\n    jobs := map[string]interface{}{\n        "data-processor":  js.handleDataProcessing,\n        "file-archiver":   js.handleFileArchival,\n        "report-generator": js.handleReportGeneration,\n    }\n    \n    for name, jobFunc := range jobs {\n        if handler, ok := jobFunc.(server.JobHandler); ok {\n            if err := server.AddJob(name, handler); err != nil {\n                return fmt.Errorf("failed to register job %s: %w", name, err)\n            }\n        } else if handler, ok := jobFunc.(server.StoppableJobHandler); ok {\n            if err := server.AddStoppableJob(name, handler); err != nil {\n                return fmt.Errorf("failed to register stoppable job %s: %w", name, err)\n            }\n        }\n    }\n    \n    return nil\n}\n\nfunc (js *JobService) HealthCheck() bool {\n    // Verify the service is running correctly\n    result := js.client.Run(&client.Task{\n        Name: "health-check",\n        Params: map[string]string{"timestamp": time.Now().String()},\n    })\n    \n    return result == base.SUCCESS\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"common-anti-patterns-to-avoid",children:"Common Anti-Patterns to Avoid"}),"\n",(0,t.jsx)(n.h3,{id:"what-not-to-do",children:"What NOT to Do"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// BAD: Resource leak\nfunc badResourceLeak(args map[string]string, signature string) bool {\n    file, _ := os.Open("important_file.txt") // No error handling\n    // Do work with file...\n    // FORGOT to close file! - Resource leak!\n    return true\n}\n\n// GOOD: Proper resource handling\nfunc goodResourceHandling(args map[string]string, signature string) bool {\n    file, err := os.Open("important_file.txt")\n    if err != nil {\n        return false\n    }\n    defer file.Close() // Proper cleanup\n    \n    // Do work with file...\n    return true\n}\n\n// BAD: Blocking without checking quit channel\nfunc badBlockingJob(args map[string]string, signature string, quit chan struct{}) bool {\n    time.Sleep(10 * time.Hour) // Blocks for 10 hours without checking quit!\n    return true\n}\n\n// GOOD: Non-blocking with quit channel check\nfunc goodNonBlockingJob(args map[string]string, signature string, quit chan struct{}) bool {\n    for i := 0; i < 1000; i++ {\n        select {\n        case <-quit:\n            return true\n        case <-time.After(10 * time.Millisecond):\n            // Check quit channel every 10ms\n        }\n        // Do small bit of work\n    }\n    return true\n}\n\n// BAD: No parameter validation\nfunc badNoValidation(args map[string]string, signature string) bool {\n    // Directly passing user input to system commands - SECURITY RISK!\n    cmd := exec.Command("sh", "-c", args["command"])\n    cmd.Run()\n    return true\n}\n\n// GOOD: Input validation\nfunc goodWithValidation(args map[string]string, signature string) bool {\n    // Validate input before using\n    if !isValidCommand(args["command"]) {\n        return false\n    }\n    \n    // Sanitize and use safely\n    sanitizedCmd := sanitizeCommand(args["command"])\n    cmd := exec.Command("/safe/whitelisted/command", sanitizedCmd)\n    return cmd.Run() == nil\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,t.jsx)(n.h3,{id:"observability-best-practices",children:"Observability Best Practices"}),"\n",(0,t.jsx)(n.p,{children:"Include proper monitoring and metrics in your Saturn CLI implementations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'type JobMetrics struct {\n    totalJobs     int64\n    successfulJobs int64\n    failedJobs    int64\n    totalDuration time.Duration\n}\n\nfunc monitoredJob(metrics *JobMetrics, args map[string]string, signature string) bool {\n    start := time.Now()\n    success := false\n    \n    defer func() {\n        duration := time.Since(start)\n        \n        atomic.AddInt64(&metrics.totalJobs, 1)\n        atomic.AddInt64(&metrics.totalDuration, duration.Nanoseconds())\n        \n        if success {\n            atomic.AddInt64(&metrics.successfulJobs, 1)\n        } else {\n            atomic.AddInt64(&metrics.failedJobs, 1)\n        }\n    }()\n    \n    // Your job logic here\n    success = performJob(args, signature)\n    \n    return success\n}\n\nfunc (jm *JobMetrics) GetStats() map[string]interface{} {\n    total := atomic.LoadInt64(&jm.totalJobs)\n    if total == 0 {\n        return map[string]interface{}{"message": "no jobs executed yet"}\n    }\n    \n    return map[string]interface{}{\n        "total_jobs":     total,\n        "successful":     atomic.LoadInt64(&jm.successfulJobs),\n        "failed":         atomic.LoadInt64(&jm.failedJobs),\n        "success_rate":   float64(atomic.LoadInt64(&jm.successfulJobs)) / float64(total) * 100,\n        "avg_duration":   time.Duration(atomic.LoadInt64(&jm.totalDuration)/total) * time.Nanosecond,\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Review the ",(0,t.jsx)(n.a,{href:"/saturncli/docs/troubleshooting",children:"Troubleshooting"})," guide for common issue resolution"]}),"\n",(0,t.jsxs)(n.li,{children:["Look at the ",(0,t.jsx)(n.a,{href:"/saturncli/docs/examples",children:"Examples"})," for practical implementations"]}),"\n",(0,t.jsxs)(n.li,{children:["Check the ",(0,t.jsx)(n.a,{href:"/saturncli/docs/architecture",children:"Architecture"})," documentation for system design understanding"]}),"\n",(0,t.jsxs)(n.li,{children:["Follow the ",(0,t.jsx)(n.a,{href:"/saturncli/docs/contributing",children:"Contributing"})," guidelines if you plan to modify Saturn CLI"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var i=r(6540);const t={},s=i.createContext(t);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);